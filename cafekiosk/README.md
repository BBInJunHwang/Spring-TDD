# Basic 01
### [테스트하기 어려운 영역]

1. 관측할때마다 다른값에 의존하는 코드
- 현재날짜, 시간
- 랜덤값
- 전역 변수
- 함수
- 사용자 입력 

2. 외부 시계에 영향을 주는 코드 
- 표준 출력 (로그)
- 메세지 발송
- 데이터베이스에 기록하기 


### [테스트하기 쉬운 영역 (순수함수)]
1. 같은 입력에 항상 같은 결과 
2. 외부 세상과 단절된 형태
3. 테스트하기 쉬운 코드 

### [키워드 정리] 
- 단위 테스트
- 수동 테스트, 자동화 테스트 
- Junit5, AssertJ 
- 해피케이스, 예외케이스
- 경계값 테스트
- 테스트 하기 쉬운/어려운 영역

### Lombok (사용가이드)
- @Data, @Setter, @AllArgu 지양 
- Entity 양뱡향 연관관계시 @ToString 시 순환 참조 문제 
=> DTO에서만 사용권장

------------


# Basic 02
### Test Driven Development
- 프로덕션 코드보다 테스트 코드를 먼저 작성해, 테스트가 구현과정을 주도
- Red (실패하는 테스트 작성)
- Green (테스트 통과 최소한의 코딩 => 최소한의 코딩 막 적어도 된다.)
- Refactor (구현 코드 개선, 테스트 통과 유지)
- 요약 : 실패하는 경우 잡기 -> 최소한 통과 수준 코드 작성 -> 리팩토링 

### TDD 방법론을 사용 해야하는 이유
- 선 기능 구현, 후 테스트 경우 
  - 시간이 모자라면 테스트 코드 누락 가능성
  - 특정 테스트 (해피케이스만) 검증할 가능성
  - 잘못된 구현을 늦게 발견할 가능성

- 선 테스트, 후기 기능 경우
  - 복잡도 낮은 테스트 코드 구현 가능 (유연, 유지보수 쉬움)
    - createOrder 경우 시간을 검증하기 어렵다
    - 이때 외부에서 주입받으면 원하는 시간대별로 검증 할 수 있다. 이런 사고가 생김
  - 쉽게 발견 어려운 엣지 케이스 놓치지 않음
  - 구현에 대한 빠른 피드백 (Red, Green 바로바로 나옴)
  - 과감한 리팩토링 가능

### [키워드 정리]
- TDD
- 레드-그린-리팩토링
- 애자일 방법론 vs 폭포수 방법론 (선행 단계가 끝나야 진행)
- 익스트림 프로그래밍 
- 스크럼, 칸반

------------


# Basic 03
### DisplayName 섬세하게!
- AS-IS : 음료 1개 추가 테스트
- TO-BE : 음료를 1개 추가 할 수 있다.
=> 한눈에 봐도 명확하게 이해 할 수 있다.

- [좀더 추가 시]
- TO-BE : 음료를 1개 추가하면 주문 목록에 담긴다.
=> 테스트 행위에 대한 결과 까지 기술하기 

- [도메인 용어를 사용하자]
- AS-IS : 특정 시간 이전에 주문을 생성하면 실패한다.
- TO-BE : 영업 시작 시간 이전에는 주문을 생성 할 수 없다.
- => 도메인 용어 사용 (개발이 아닌 실제로 쓰이는 단어)

## BDD (Behavior Driven Development)
- TDD 파생된 개발 방법
- 함수 단위 테스트 집중보다, 시나리오 기반 테스트 집중
- 개발자가 아닌 사람이 봐도 이해할 수 있는 추상화 수준 

1. given : 시나리오 진행에 필요한 모든 준비 과정 (객체, 값, 상태 셋팅)
2. when : 시나리오 행동 진행 
3. then : 시나리오 진행에 대한 결과 검증 

------------

# Basic 04
## Persistence Layer
- Data Access 역할
- 비즈니스 가공 로직이 포함되어서는 안된다.
- => Data 대한 CRUD만 집중한 레이어 

## Business Layer
- 비즈니스 로직을 구현
- Persistence Layer 와 상호작용 (Data CRUD 행위) 통해 비즈니스 로직 전개
- 트랜잭션 보장해야한다.
- Business Layer + Persistence Layer 두개 테스트 통합 테스트 느낌으로 진행


# Basic 05
## 테스트 시 @Transactional vs TearDown()
- 테스트 코드에 @Transactional 가 존재 시 실제 서비스 레이어에 트랜잭션 유무를 알 수 없다.
- -> 뒤늦게 알 수 있다.
- -> 그러나 insert/update 에서 사용하는건 상식이다.

- TearDown 사용하면 실제 환경과 동일하게 테스트 할 수 있다.
- -> 그러나 매 테스트 코드에 작성 해줘야 한다.
- 두개의 차이는 논쟁이 있는 부분이다.

## 리팩토링 
- Red -> Green -> Refactoring
- 리팩토링 단계에서 응용서비스 내 복잡한 비즈니스 존재시 정리 필요
- stream, filter, map 등 데이터 가공 로직은 private 메소드로 분리
- 추출한 private 메소드는 순서대로 정리

# Basic 06
## @Transaction (readOnly = true)
- 읽기 전용, create/update/delete  동작 안함
- JPA에서 이점 : 1차캐시 스냅샷 저장시 트랜잭션 flush 시점에 변경감지 (update 쿼리 수행)
- readOnly = true 시 CUD 동작을 하지 않기 때문에 성능 향상
- CQRS - Command / Read 분리 
- 대부분 서비스는 압도적으로 Read가 많다.
- 이때 Command / Read 분리 시 서로 연관 없도록 만든다. 부하에 따라 서로 영향 없음
- 예시) master db 는 command, slave db는 Read만 사용
- 서비스 상단에 readOnly=true를 걸고, 메소드 단위로 @Transaction 건다.

## Presentation layer
- 외부세계 요청을 가장 먼저 받는 계층
- 파라미터 최소한 검증 수행

## Mock
- MockMvc : 가짜 객체를 사용해 스프링 MVC 동작을 재현
- 컨트롤러 관련 빈만 띄우는 어노테이션

- MockBean : 컨트롤러 테스트시 서비스 클래스는 안띄우기 때문에 MockBean 처리를 해준다.

## @Valid
- NotBlank / NotNull 검사는 컨트롤러 Request에서 String에 대한 최소한의 검사용으로 '빈값' 정도만 검사하는게 좋다.
- Max(20) 이런 사이즈 검사는 서비스 레이어 혹은 도메인 객체 생성자 안에서 검사 책임으로 넘기는게 좋으며, 이런 시야를 길러야한다.
- 하나의 validation 으로 보이지만, 하나의 Layer에서 전부 검사 할 필요는 없다!

## Controller-Service 의존성 분리
- Controller 에서 사용하는 Dto를 그대로 Serivce로 넘겨줄 시 두 레이어간 의존관계가 생긴다.
- => 컨트롤러/서비스를 모듈로 분리시 허들이 생긴다.

### best practice 
- 서비스가 컨트롤러를 알고 있다 -> 의존이 있다 
- 하위 레이어가 상위 레이어를 몰라야 제일 좋다.
- 컨트롤러 레이어가 서비스 빈을 주입받아서 사용한다. (상위는 하위를 호출하기 때문에 당연히 알고 있어야 하지만..)
- 역으로 하위가 상위를 알게되는건 좋지 않다. (서비스가 컨트롤러를 알아야하기 때문..)
- 컨트롤러 DTO / 서비스 DTO 를 분리하고, 컨트롤러 DTO에서 서비스 DTO로 변환 시켜서 넘겨준다.
- 당장은 불편해 보이지만, 후에 서비스가 다른곳에서 사용하게 될때 컨트롤러 DTO도 알아야하는 경우가 생기기 때문에, 영향을 받지 않도록 관리하면 의존성/책임분리에 유리하다.
- 