# Basic 01
### [테스트하기 어려운 영역]

1. 관측할때마다 다른값에 의존하는 코드
- 현재날짜, 시간
- 랜덤값
- 전역 변수
- 함수
- 사용자 입력 

2. 외부 시계에 영향을 주는 코드 
- 표준 출력 (로그)
- 메세지 발송
- 데이터베이스에 기록하기 


### [테스트하기 쉬운 영역 (순수함수)]
1. 같은 입력에 항상 같은 결과 
2. 외부 세상과 단절된 형태
3. 테스트하기 쉬운 코드 

### [키워드 정리] 
- 단위 테스트
- 수동 테스트, 자동화 테스트 
- Junit5, AssertJ 
- 해피케이스, 예외케이스
- 경계값 테스트
- 테스트 하기 쉬운/어려운 영역

### Lombok (사용가이드)
- @Data, @Setter, @AllArgu 지양 
- Entity 양뱡향 연관관계시 @ToString 시 순환 참조 문제 
=> DTO에서만 사용권장

------------


# Basic 02
### Test Driven Development
- 프로덕션 코드보다 테스트 코드를 먼저 작성해, 테스트가 구현과정을 주도
- Red (실패하는 테스트 작성)
- Green (테스트 통과 최소한의 코딩 => 최소한의 코딩 막 적어도 된다.)
- Refactor (구현 코드 개선, 테스트 통과 유지)
- 요약 : 실패하는 경우 잡기 -> 최소한 통과 수준 코드 작성 -> 리팩토링 

### TDD 방법론을 사용 해야하는 이유
- 선 기능 구현, 후 테스트 경우 
  - 시간이 모자라면 테스트 코드 누락 가능성
  - 특정 테스트 (해피케이스만) 검증할 가능성
  - 잘못된 구현을 늦게 발견할 가능성

- 선 테스트, 후기 기능 경우
  - 복잡도 낮은 테스트 코드 구현 가능 (유연, 유지보수 쉬움)
    - createOrder 경우 시간을 검증하기 어렵다
    - 이때 외부에서 주입받으면 원하는 시간대별로 검증 할 수 있다. 이런 사고가 생김
  - 쉽게 발견 어려운 엣지 케이스 놓치지 않음
  - 구현에 대한 빠른 피드백 (Red, Green 바로바로 나옴)
  - 과감한 리팩토링 가능

### [키워드 정리]
- TDD
- 레드-그린-리팩토링
- 애자일 방법론 vs 폭포수 방법론 (선행 단계가 끝나야 진행)
- 익스트림 프로그래밍 
- 스크럼, 칸반

------------


# Basic 03
### DisplayName 섬세하게!
- AS-IS : 음료 1개 추가 테스트
- TO-BE : 음료를 1개 추가 할 수 있다.
=> 한눈에 봐도 명확하게 이해 할 수 있다.

- [좀더 추가 시]
- TO-BE : 음료를 1개 추가하면 주문 목록에 담긴다.
=> 테스트 행위에 대한 결과 까지 기술하기 

- [도메인 용어를 사용하자]
- AS-IS : 특정 시간 이전에 주문을 생성하면 실패한다.
- TO-BE : 영업 시작 시간 이전에는 주문을 생성 할 수 없다.
- => 도메인 용어 사용 (개발이 아닌 실제로 쓰이는 단어)

## BDD (Behavior Driven Development)
- TDD 파생된 개발 방법
- 함수 단위 테스트 집중보다, 시나리오 기반 테스트 집중
- 개발자가 아닌 사람이 봐도 이해할 수 있는 추상화 수준 

1. given : 시나리오 진행에 필요한 모든 준비 과정 (객체, 값, 상태 셋팅)
2. when : 시나리오 행동 진행 
3. then : 시나리오 진행에 대한 결과 검증 

------------

# Basic 04
## Persistence Layer
- Data Access 역할
- 비즈니스 가공 로직이 포함되어서는 안된다.
- => Data 대한 CRUD만 집중한 레이어 

## Business Layer
- 비즈니스 로직을 구현
- Persistence Layer 와 상호작용 (Data CRUD 행위) 통해 비즈니스 로직 전개
- 트랜잭션 보장해야한다.
- Business Layer + Persistence Layer 두개 테스트 통합 테스트 느낌으로 진행


# Basic 05
## 테스트 시 @Transactional vs TearDown()
- 테스트 코드에 @Transactional 가 존재 시 실제 서비스 레이어에 트랜잭션 유무를 알 수 없다.
- -> 뒤늦게 알 수 있다.
- -> 그러나 insert/update 에서 사용하는건 상식이다.

- TearDown 사용하면 실제 환경과 동일하게 테스트 할 수 있다.
- -> 그러나 매 테스트 코드에 작성 해줘야 한다.
- 두개의 차이는 논쟁이 있는 부분이다.

## 리팩토링 
- Red -> Green -> Refactoring
- 리팩토링 단계에서 응용서비스 내 복잡한 비즈니스 존재시 정리 필요
- stream, filter, map 등 데이터 가공 로직은 private 메소드로 분리
- 추출한 private 메소드는 순서대로 정리